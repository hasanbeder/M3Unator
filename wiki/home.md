# M3Unator - Web Directory Playlist Creator

**Version:** 1.0.2

**Author:** Hasan Beder

**License:** GPL-3.0

**GitHub:** [https://github.com/hasanbeder/M3Unator](https://github.com/hasanbeder/M3Unator)

**Table of Contents:**

1. [Introduction](#introduction)
2. [Features](#features)
3. [Supported Media Formats](#supported-media-formats)
4. [Usage](#usage)
    *   [User Interface](#user-interface)
    *   [Quick Start](#quick-start)
    *   [Example Usage Scenarios](#example-usage-scenarios)
5. [Technical Details](#technical-details)
    *   [Code Structure](#code-structure)
        *   [`PlaylistGenerator` Class](#playlistgenerator-class)
        *   [`LogCache` Class](#logcache-class)
    *   [Algorithms](#algorithms)
        *   [Directory Scanning Algorithm](#directory-scanning-algorithm)
        *   [Playlist Creation Algorithm](#playlist-creation-algorithm)
    *   [Data Structures](#data-structures)
    *   [Concurrency Model](#concurrency-model)
    *   [Error Handling](#error-handling)
    *   [Browser Compatibility](#browser-compatibility)
    *   [Security](#security)
    *   [Performance](#performance)
    *   [CSS (GM\_addStyle) Usage](#css-gm_addstyle-usage)
    *   [URL Handling](#url-handling)
    *   [Timers](#timers)
6. [Limitations](#limitations)
7. [Future Enhancements](#future-enhancements)
8. [Troubleshooting](#troubleshooting)
9. [Contributing](#contributing)
10. [License](#license)

## Introduction

M3Unator is a userscript that automatically generates M3U and M3U8 playlists from web server directory listings. It allows you to easily create playlists from your music and videos located in folders, without having to navigate through the web interface. It's compatible with directory listings generated by popular web servers like Apache, Nginx, and LiteSpeed.

M3Unator offers advanced features such as recursive scanning, customizable file type selection, depth limitation, detailed logging, and a user-friendly interface.

## Features

*   **Automatic Playlist Generation:** Creates M3U/M3U8 playlists from web server directory listings.
*   **Wide Media Format Support:** Supports a wide range of video (MP4, MKV, AVI, etc.) and audio (MP3, M4A, FLAC, etc.) formats.
*   **Recursive Directory Scanning:** Option to scan media files in subdirectories up to a specified depth.
*   **Customizable File Type Selection:** Allows users to include only specific file types (video, audio, or both).
*   **Depth Limitation:** Offers an option to set the maximum depth for recursive scanning (current directory or custom depth).
*   **Progress Tracking:** Shows the progress of the scanning and playlist creation process in real time.
*   **Detailed Logging:** Keeps a detailed log of the scanning process, found files, errors, and other important events.
*   **Error Handling:** Handles errors gracefully and displays informative error messages to the user.
*   **User-Friendly Interface:** Provides an intuitive interface designed for ease of use.
*   **Drag-and-Drop Movable Interface:** The user interface can be moved anywhere on the screen.
*   **Dark Theme:** Features an eye-pleasing, stylish dark theme interface.
*   **Caching:** Uses a caching mechanism (`seenUrls`) to reduce redundant requests and improve performance.
*   **Pause/Resume/Cancel:** The scanning process can be paused, resumed, or canceled altogether.
*   **Statistics:** Displays statistics about the scanning process, such as the total number of files, number of video files, number of audio files, number of directories scanned, depth level, and number of errors.

## Supported Media Formats

M3Unator supports the following video and audio formats:

**Video:**

.mp4, .mkv, .avi, .webm, .mov, .flv, .wmv, .m4v, .mpg, .mpeg, .3gp, .vob, .ts, .mts, .m2ts, .divx, .xvid, .asf, .ogv, .rm, .rmvb, .wtv, .qt, .hevc, .f4v, .swf, .vro, .ogx, .drc, .gifv, .mxf, .roq, .nsv

**Audio:**

.mp3, .m4a, .wav, .flac, .aac, .ogg, .wma, .opus, .aiff, .ape, .mka, .ac3, .dts, .m4b, .m4p, .m4r, .mid, .midi, .mp2, .mpa, .mpc, .ra, .tta, .voc, .vox, .amr, .awb, .dsf, .dff, .alac, .wv, .oga, .sln, .aif, .pcm

## Usage

### User Interface

The M3Unator user interface consists of the following components:

1. **Launcher Button:** Click the launcher button that appears in the top-right corner of the web page to activate the script.
2. **Title:** "M3Unator" title and version information.
3. **Information and Social Media Links:** You can get information about the script, access GitHub and Twitter links by clicking the info icon.
4. **Close Button:** Closes the user interface.
5. **Playlist Name Input Field:** Allows you to enter a name for the playlist to be created.
6. **Format Selector (Dropdown Menu):** Allows you to select the playlist format (M3U or M3U8).
7. **File Type Selectors (Checkboxes):**
    *   **Video:** Check this option to include video files.
    *   **Audio:** Check this option to include audio files.
8. **Recursive Scanning Option (Checkbox):** Check this option to scan subdirectories.
9. **Depth Controls:**
    *   **Current Directory (Radio Button):** Select this to scan only the current directory.
    *   **Custom Depth (Radio Button):** Select this to scan subdirectories up to a specific depth, and enter the depth value in the text box below.
    *   **Maximum Depth Input Field:** When the custom depth option is selected, this allows you to enter the maximum depth (subdirectory level) to be scanned.
10. **Create Playlist Button:** Starts the scanning and playlist creation process.
11. **Control Buttons (Visible After Scanning Starts):**
    *   **Pause:** Pauses the scanning process temporarily.
    *   **Resume:** Resumes a paused scanning process.
    *   **Cancel:** Cancels the scanning process completely.
12. **Statistics Bar (Visible After Scanning Starts):**
    *   **Total Files:** Total number of files scanned.
    *   **Video Files:** Number of video files found.
    *   **Audio Files:** Number of audio files found.
    *   **Directories:** Number of directories scanned.
    *   **Depth Level:** Current scanning depth.
    *   **Errors:** Number of errors encountered during the scan.
13. **Log Window (Expandable):**
    *   **Log Toggle Button:** Shows/hides the log window.
    *   **Activity Indicator:** Shows the status of the scanning operation (active, paused, canceled, completed).
    *   **Log Content:** Displays detailed information about the scanning process.

### Quick Start

1. Install the M3Unator userscript in your browser.
2. Navigate to the web directory where you want to create a playlist.
3. Click the launcher button in the top-right corner to open the M3Unator interface.
4. Enter a name for the playlist (or use the default name).
5. Select the file types you want to include (video and/or audio).
6. If you want to enable recursive scanning, check the "Recursive Scanning" option.
7. If you're using recursive scanning and need a depth limit, select "Custom Depth" and enter the maximum depth value. Otherwise, all subdirectories will be scanned.
8. Click the "Create Playlist" button.
9. When the scanning process is complete, the playlist will be downloaded automatically.

### Example Usage Scenarios

*   **Scenario 1: Creating a playlist of all MP3 files in a specific folder:**
    1. Navigate to the web directory containing the MP3 files.
    2. Open the M3Unator interface.
    3. Enter a name for the playlist (e.g., "My Favorite MP3s").
    4. Check the "Audio" file type option, uncheck "Video".
    5. Uncheck "Recursive Scanning", "Current Directory" should remain selected.
    6. Click the "Create Playlist" button.
*   **Scenario 2: Creating a playlist of all music files (MP3, FLAC, etc.) in all subdirectories of a music archive:**
    1. Navigate to the main directory of the music archive.
    2. Open the M3Unator interface.
    3. Enter a name for the playlist (e.g., "Entire Music Archive").
    4. Check the "Audio" file type option, uncheck "Video".
    5. Check the "Recursive Scanning" option.
    6. To scan all subdirectories, do not select "Custom Depth", or select "Custom Depth" and set the maximum depth value to a high number (e.g., 99).
    7. Click the "Create Playlist" button.
*   **Scenario 3: Creating a playlist of all video files (MP4, MKV, etc.) in a specific folder and the first two subdirectory levels:**
    1. Navigate to the web directory containing the video files.
    2. Open the M3Unator interface.
    3. Enter a name for the playlist (e.g., "Selected Videos").
    4. Check the "Video" file type option, uncheck "Audio".
    5. Check the "Recursive Scanning" option.
    6. Select "Custom Depth" and set the maximum depth value to 2.
    7. Click the "Create Playlist" button.

## Technical Details

### Code Structure

The M3Unator userscript mainly consists of two classes: `PlaylistGenerator` and `LogCache`.

#### `PlaylistGenerator` Class

This class contains the core functionality of the script. It's responsible for generating the user interface, scanning directories, creating playlists, and handling user input.

**Important Properties:**

*   **`constructor()`:** The constructor method of the class. Initializes necessary variables, sets default values, creates the `extensionMap` data structure for supported file types, and calls the `init()` method to build the interface.
*   **`init()`:** Builds the user interface, adds event listeners, and initializes the script.
*   **`createComponent(type, props)`:** Template function for dynamically creating UI elements.
*   **`scanDirectory(url, currentPath, depth)`:** The **asynchronous** method that scans the specified directory (and subdirectories) for media files.
    *   `url`: The URL of the directory to be scanned.
    *   `currentPath`: The relative path of the current directory (initially an empty string).
    *   `depth`: The current scanning depth.
    *   Works recursively.
    *   Uses `fetchWithRetry()` to get directory contents.
    *   Parses HTML and extracts file and directory links from `href` attributes.
    *   Checks file types using `isMediaFileOptimized()`.
    *   Adds found media files to the `entries` array.
    *   Adds scanned directories to the `seenUrls` set.
    *   Supports pause, resume, and cancel operations.
    *   Updates statistics (`state.stats`).
    *   Adds log entries (`addLogEntry()`).
    *   Processes files in batches using `Promise.all`.
    *   Limits the number of concurrent directory scans with `parallelLimit`.
*   **`createPlaylist(entries)`:** The method that creates an M3U/M3U8 playlist from the media files in the `entries` array.
    *   `entries`: The list of media files to be added to the playlist (each an object with `title` and `url` properties).
    *   Generates the playlist content and returns it.
    *   Sorts files by type (video/audio) and then by title/filename.
    *   Properly decodes file paths/names with `decodedTitle`.
*   **`fetchWithRetry(url, options, retries)`:** The **asynchronous** helper method used to fetch data from the specified URL.
    *   `url`: The URL to fetch data from.
    *   `options`: Options for the fetch request (e.g., headers, timeout).
    *   `retries`: The number of times to retry if it fails.
    *   Retries the request a certain number of times before throwing an error.
*   **`isMediaFileOptimized(fileName)`:** The optimized version, checks whether the file is a media file based on the file name extension. Uses the `extensionMap` data structure.
*   **`handleError(error, context)`:** The method used to catch and handle errors.
    *   `error`: The error object.
    *   `context`: Information identifying the error (method name, etc.).
    *   Logs the error message.
    *   Displays an error notification to the user.
    *   Increments `state.stats.errors.total`.
*   **`addLogEntry(message, type)`:** Adds a new entry to the log.
    *   `message`: The message to be added to the log.
    *   `type`: The type of the log entry ('success', 'error', 'warning', 'info').
    *   Adds the log entry using the `logCache` object.
    *   Calls the `updateLogUI()` method at specific intervals.
*   **`updateLogUI()`:** Updates the log window.
    *   Gets recent log entries with `logCache.getSummary()`.
    *   Updates the content in the log window.
*   **`showToast(message, type, duration)`:** Displays a notification to the user.
    *   `message`: The notification message.
    *   `type`: The notification type ('success', 'error', 'warning').
    *   `duration`: How long the notification will be displayed (in milliseconds).
*   **`reset(options)`:** Resets the script, clears variables, and restores the interface to its default state.
    *   `options`: Reset options (e.g., `uiOnly`, `keepLogs`).
*   **`updateCounter(count)`:** Updates the statistics bar.
*   **`sanitizeInput(input)`:** Sanitizes the playlist name entered by the user, removes invalid characters, and limits its length.
*   **`decodeString(str, type)`:** Decodes URL-encoded or HTML-encoded characters.
    *   `str`: The string to be decoded.
    *   `type`: The decoding type (`'url'`, `'html'`, or `'both'`).
*   **`normalizeUrl(url)`:** Normalizes the URL, removing unnecessary slashes.
*   **`extractFileInfo(path)`:** Extracts information such as filename and directory path from a URL.

**Other Important Variables:**

*   **`state`:** The object that holds the current state of the script.
    *   `isGenerating`: Indicates whether the playlist generation process is in progress.
    *   `isPaused`: Indicates whether the scanning process is paused.
    *   `selectedFormat`: The selected playlist format ('m3u' or 'm3u8').
    *   `includeVideo`: Whether to include video files.
    *   `includeAudio`: Whether to include audio files.
    *   `maxEntries`: The maximum number of files to be added to the playlist.
    *   `timeoutMs`: The request timeout period (in milliseconds).
    *   `retryCount`: The number of times to retry failed requests.
    *   `maxDepth`: The maximum depth for recursive scanning (-1 means unlimited).
    *   `maxSeenUrls`: The maximum number of directories to keep in the cache.
    *   `stats`: The object that holds statistics about the scanning process.
*   **`initialStats`:** Contains default values for `state.stats`.
*   **`entries`:** The array that holds the list of found media files (each element is an object with `title` and `url` properties).
*   **`seenUrls`:** The `Set` object that holds the URLs of scanned directories (used for caching).
*   **`videoFormats`:** The list of supported video file extensions.
*   **`audioFormats`:** The list of supported audio file extensions.
*   **`extensionMap`:** The `Map` object that maps file extensions to file types ('video' or 'audio').
*   **`domElements`:** The object containing references to important DOM elements in the user interface.
*   **`icons`:** The object containing definitions of SVG icons used in the user interface.
*   **`templates`:** The object containing template functions used to dynamically create UI elements.
*   **`sortOptions`:** Sorting options to be used with the `localeCompare` method.

#### `LogCache` Class

This class is used to cache and manage log entries.

**Important Properties:**

*   **`constructor(maxSize)`:** The constructor method of the class.
    *   `maxSize`: The maximum number of log entries to keep in the cache (default 100).
    *   `logs`: The array that holds the log entries.
    *   `stats`: The object that holds statistics about log entries (`totalLogs`, `skippedLogs`).
*   **`add(message, type)`:** Adds a new log entry to the cache.
    *   `message`: The log message.
    *   `type`: The type of the log entry.
    *   Adds the log entry to the `logs` array.
    *   Increments the `totalLogs` counter.
    *   If the cache size exceeds `maxSize`, it removes the oldest entry and increments the `skippedLogs` counter.
*   **`getSummary()`:** Returns a summary of the log entries and statistics.
*   **`clear()`:** Clears the cache.

### Algorithms

#### Directory Scanning Algorithm

The directory scanning algorithm is implemented in the `scanDirectory()` method of the `PlaylistGenerator` class. The algorithm works recursively and follows these steps:

1. **Initialization:**
    *   The `scanDirectory()` method is called with the URL of the directory to be scanned, the relative path (initially empty), and the depth (initially 0).
    *   The recursion depth is limited by `maxDepth` (-1 for unlimited).
    *   Pause and cancel requests are checked.
    *   Scanned directories are cached in the `seenUrls` set, they are not scanned again.
    *   If the size of `seenUrls` exceeds `maxSeenUrls`, old entries are deleted.

2. **Get Directory Contents:**
    *   The directory contents (HTML) are fetched using the `fetchWithRetry()` method.
    *   `fetchWithRetry` retries failed requests up to `retryCount` times and applies a timeout (`timeoutMs`).
    *   HTTP errors (404, 500, etc.) and timeouts are handled by `handleError`.

3. **Parse HTML:**
    *   The fetched HTML content is parsed using `DOMParser`.
    *   File and directory links are extracted from the `href` attributes of `<a>` tags.
    *   HTML formats of Apache/Nginx and LiteSpeed servers are handled separately (checked with the `isLiteSpeed` variable).
    *   `href` values are corrected for URL-encoded characters (with `decodeString`), relative paths (`new URL(href, normalizedUrl)`), and repeated slashes (`normalizeUrl`).

4. **Separate Files and Directories:**
    *   `href` values are separated into files and directories based on whether they end with a slash.

5. **Process Files:**
    *   Files are processed in batches of size `batchSize` (e.g., 100).
    *   Each file batch is processed concurrently with `Promise.all`.
    *   The file type is checked with `isMediaFileOptimized` (using `extensionMap`).
    *   If the file is one of the allowed types (video/audio) and the `includeVideo`/`includeAudio` options are active, it is added to the `entries` array.
    *   Statistics (`state.stats`) are updated each time a file is processed.
    *   The interface is updated every `batchSize`'s multiple and at the end of the batch (for example, every 20 files) (log and statistics).

6. **Scan Directories (Recursion):**
    *   The `shouldScanSubdir` variable determines whether to scan subdirectories (depth check).
    *   Directories are scanned concurrently in a limited number by `parallelLimit` (e.g., 15).
    *   `queue` (queue) and `activeRequests` (active requests) are used to manage concurrent `scanDirectory` calls.
    *   The `scanDirectory()` method is called recursively for each directory (depth is incremented by 1).
    *   Errors are handled by `handleError`.

7. **Update Log and Statistics:**
    *   The log (`addLogEntry`) and statistics (`state.stats`) are updated each time a directory is scanned and each file is processed.
    *   The log is managed by `logCache` (size limitation).
    *   The log and statistics are reflected in the interface at specific intervals (`updateLogUI`, `updateCounter`).

#### Playlist Creation Algorithm

The playlist creation algorithm is implemented in the `createPlaylist()` method of the `PlaylistGenerator` class. The algorithm follows these steps:

1. **Input:** `entries` array (list of found media files).
2. **Decoding:** URL and HTML encoded characters in file paths (`title`) are decoded using `decodeString`.
3. **Type Detection:** Each file is determined to be a video or audio file using the `videoFormats` and `audioFormats` lists.
4. **Sorting:** Files are sorted first by type (video/audio), then by depth (`depth`), and finally by file name (`decodedTitle`). The sorting operation is done using the `localeCompare` method, and numeric sorting (`numeric: true`) is enabled with `sortOptions`.
5. **Content Generation:** M3U/M3U8 playlist content is generated using the sorted file list.
    *   An `#EXTINF` line (file name information) and the file URL are added for each file.
6. **Output:** The generated playlist content is returned.

### Data Structures

*   **`extensionMap` (`Map`):** A `Map` object used to map file extensions to file types ('video' or 'audio'). It is used in the `isMediaFileOptimized` method to quickly determine the file type. Keys are file extensions (e.g., "mp4", "mp3"), and values are file types (e.g., "video", "audio").
*   **`entries` (Array):** Holds the list of found media files. Each element is an object with `title` (file path) and `url` (file URL) properties.
*   **`seenUrls` (`Set`):** A `Set` object that holds the URLs of scanned directories. It is used to prevent the same directory from being scanned repeatedly. This is a caching mechanism.
*   **`state` (Object):** Holds the current state of the script. Contains properties like `isGenerating`, `isPaused`, `selectedFormat`, `includeVideo`, `includeAudio`, `maxEntries`, `timeoutMs`, `retryCount`, `maxDepth`, `maxSeenUrls`, `stats`.
*   **`initialStats` (Object):** Contains default values for `state.stats`.
*   **`videoFormats` (Array):** Contains the list of supported video file extensions.
*   **`audioFormats` (Array):** Contains the list of supported audio file extensions.
*   **`logCache` (Object):** An instance of the `LogCache` class. Used to cache and manage log entries.

### Concurrency Model

M3Unator uses **Promises** and **`async/await`** keywords to manage concurrent operations.

*   **`scanDirectory()`:** This method utilizes concurrency when scanning a directory and processing its subdirectories.
    *   **File Processing:** Files are processed concurrently in batches (of size `batchSize`) using `Promise.all`.
    *   **Directory Scanning:** Recursive calls (to scan subdirectories) are made concurrently, limited by `parallelLimit`. The `queue` (queue) and `activeRequests` (active requests) variables manage the number of concurrently running `scanDirectory` calls. The `while (queue.length > 0 || activeRequests.size > 0)` loop manages concurrency by adhering to the `parallelLimit` and waiting for queued directories or ongoing requests.
*   **`fetchWithRetry()`:** This method makes network requests concurrently and retries failed requests a certain number of times.
*   **`updateLogUI()`:** This method uses `setTimeout` and `requestAnimationFrame` when updating the log window to avoid freezing the interface.

This model allows the scanning process to complete faster and prevents the user interface from freezing.

### Error Handling

M3Unator uses `try...catch` blocks and the `handleError()` method to catch and handle errors that may occur during the scanning and playlist creation process.

*   **`try...catch` blocks in `scanDirectory()`:**
    *   Catches errors that may occur during fetching directory contents (`fetchWithRetry`) and parsing HTML.
    *   Catches errors that may occur during recursive calls.
*   **`try...catch` blocks in `fetchWithRetry()`:**
    *   Catches errors that may occur during network requests (HTTP errors, timeouts).
    *   Retries failed requests a certain number of times.
*   **`handleError(error, context)` method:**
    *   Handles uncaught errors or errors thrown by `try...catch` blocks.
    *   Identifies the error using the `error` object and `context` information.
    *   Displays an error message to the user with `showToast()`.
    *   Logs the error with `addLogEntry()`.
    *   Increments `state.stats.errors.total`.
*   **Error Types:**
    *   **Network Errors:** Occur when the server cannot be connected to, or the request times out (e.g., `AbortError`, `TimeoutError`).
    *   **HTTP Errors:** Occur when the server returns an error code (e.g., 404 Not Found, 500 Internal Server Error).
    *   **Decoding Errors:** Occur when URL or HTML encoded characters cannot be decoded.
    *   **Other Errors:** Unexpected errors (e.g., `TypeError`, `ReferenceError`).

### Browser Compatibility

The M3Unator script is designed to be compatible with **modern web browsers**. It has been tested on the following browsers:

*   Google Chrome (latest version)
*   Mozilla Firefox (latest version)
*   Microsoft Edge (latest version)
*   Safari (latest version)

Note that the script may not work properly on older browser versions or other browsers.

### Security

M3Unator takes the following measures to protect user data security and privacy:

*   **No Data Collection:** The script does not collect any user data.
*   **Local Processing:** All processing is done locally in the user's browser.
*   **No External Requests (Except for directory list):** The script only makes requests to the web server where the directory listing is located. It does not communicate with any third-party servers.
*   **Input Sanitization:** The `sanitizeInput()` method is used to sanitize the playlist name entered by the user, removing potentially harmful characters.
*   **Code Review:** The source code is publicly available on GitHub and can be reviewed by anyone.

### Performance

M3Unator incorporates several optimizations to ensure good performance:

*   **Caching:** The `seenUrls` set is used to cache scanned directories, avoiding redundant requests to the server.
*   **Batch Processing:** Files are processed in batches to reduce the overhead of individual file operations.
*   **Concurrency:** `Promise.all` and `async/await` are used to perform multiple operations concurrently, speeding up the scanning process.
*   **Optimized File Type Detection:** The `extensionMap` data structure allows for fast file type detection.
*   **Throttling:** The `updateLogUI` method uses throttling to prevent excessive updates to the user interface, which can impact performance.
*   **Memory Management:**
    *   Releases references to large objects when they are no longer needed, allowing the garbage collector to reclaim memory.
    *   Clears the `seenUrls` cache when it reaches a certain size (`maxSeenUrls`).
    *   Uses `global.gc && global.gc()` to suggest garbage collection after processing large batches of files, but only when this function exists (primarily in testing environments, not in regular browsers).

### CSS (GM\_addStyle) Usage

The `GM_addStyle` function is used extensively to inject CSS rules into the webpage, providing a consistent and visually appealing style for the M3Unator user interface.

*   **Encapsulation:** `GM_addStyle` allows the script to define its styles without interfering with the existing styles of the webpage.
*   **Modularity:** CSS rules are grouped logically, making it easier to maintain and update the styles.
*   **Dynamic Styling:** `GM_addStyle` can be used to dynamically add or modify styles based on user interactions or script logic.
*   **Specificity:** The injected CSS rules have high specificity, ensuring that they override any conflicting styles on the webpage.
*   **No External Stylesheets:** This method eliminates the need for external CSS files, making the script self-contained.

Each CSS block targets specific elements within the M3Unator UI, providing a cohesive and polished look. The use of descriptive class names (e.g., `M3Unator-button`, `M3Unator-log-entry`) makes it easy to understand which elements each style block affects.

### URL Handling

M3Unator uses several techniques to handle URLs correctly and efficiently:

*   **`normalizeUrl(url)`:** This function normalizes URLs by removing redundant slashes. This ensures consistency and avoids issues caused by variations in URL formatting.
*   **`decodeString(str, type)`:** This function decodes URL-encoded and HTML-encoded characters in strings. This is important for handling filenames and paths that may contain special characters.
    *   It supports decoding both URL encoding (`%20` for spaces, etc.) and HTML entities (`&amp;`, `&lt;`, etc.).
    *   It handles potential errors during decoding, ensuring robustness.
*   **`new URL(href, normalizedUrl)`:** This is used to construct absolute URLs from relative URLs extracted from the `href` attributes of `<a>` tags. The `normalizedUrl` (the base URL of the current directory) is used as the base for resolving relative URLs.
*   **`extractFileInfo(path)`:** This function extracts the filename and directory path from a URL. It uses `decodeString` to handle encoded characters in the URL.

### Timers

M3Unator utilizes timers for specific functionalities:

*   **`setTimeout` in `updateLogUI`:** The `updateLogUI` function uses a `setTimeout` of 100ms to throttle the updates to the log window. This prevents the UI from becoming unresponsive due to too many frequent updates. The `_updateLogUITimeout` variable stores the timeout ID, allowing clearing of the previous timeout if a new update is scheduled before the previous one has executed.
*   **`requestAnimationFrame` in `updateLogUI`:** Inside the `setTimeout` callback, `requestAnimationFrame` is used to schedule the actual DOM update. This ensures that the UI updates are synchronized with the browser's rendering pipeline, leading to smoother animations and transitions.

These timers contribute to an efficient and user-friendly experience.

## Limitations

*   **Very Large Directories:** Scanning very large directories with numerous subdirectories and files may take a considerable amount of time, especially on slower connections.
*   **Server-Side Limitations:** The script's performance is dependent on the server's response time and bandwidth.
*   **Browser Compatibility:** While tested on major browsers, the script might not function correctly on older or less common browsers.
*   **JavaScript Dependent:** Requires JavaScript to be enabled in the browser.
*   **HTML Structure Dependent:** Relies on the HTML structure of the directory listing. Significant changes to the server's HTML output format might break the script.
*   **File Name Encoding:** Assumes file names are UTF-8 encoded. Issues might occur with other encodings.

## Future Enhancements

*   **Regular Expression Support for File Inclusion/Exclusion:** Allow users to specify regular expressions to include or exclude specific files or directories based on their names.
*   **Playlist Customization:** Provide more options for customizing the generated playlist, such as adding metadata or using different templates.
*   **Improved Error Handling:** Implement more specific error handling for different types of network and server errors.
*   **User Settings Persistence:** Save user preferences (e.g., selected format, include video/audio) using `GM_setValue` and `GM_getValue`.
*   **Support for Other Playlist Formats:** Add support for other playlist formats, such as PLS or ASX.
*   **Performance Optimizations:** Continuously explore ways to improve the performance of the scanning and playlist creation process.
*   **Accessibility:** Improve the accessibility of the user interface for users with disabilities.
*   **Internationalization:** Support multiple languages.

## Troubleshooting

*   **Playlist Not Downloading:**
    *   Ensure that your browser is not blocking downloads.
    *   Check if the generated playlist is empty (no media files found).
    *   Try disabling other browser extensions that might interfere with downloads.
*   **Script Not Working:**
    *   Make sure that the script is enabled in your browser's extension/userscript manager.
    *   Verify that you are on a web server directory listing page.
    *   Check the browser's developer console (Ctrl+Shift+I or F12) for any error messages related to the script.
*   **Slow Performance:**
    *   Large directories and slow server connections can impact performance.
    *   Reduce the scanning depth if using recursive scanning.
    *   Try again later if the server might be experiencing high load.

## Contributing

Contributions to M3Unator are welcome! If you'd like to contribute, please follow these steps:

1. Fork the repository on GitHub: [https://github.com/hasanbeder/M3Unator](https://github.com/hasanbeder/M3Unator)
2. Create a new branch for your feature or bug fix.
3. Make your changes and commit them with clear and concise commit messages.
4. Write tests for your changes if applicable.
5. Ensure your code follows the existing coding style.
6. Submit a pull request to the main branch of the original repository.

**Bug Reports:**

If you encounter any bugs or issues, please report them on the GitHub issue tracker: [https://github.com/hasanbeder/M3Unator/issues](https://github.com/hasanbeder/M3Unator/issues)

Please include the following information in your bug report:

*   Browser and operating system
*   Steps to reproduce the bug
*   Expected behavior
*   Actual behavior
*   Error messages (if any)
*   Screenshots (if applicable)

**Feature Requests:**

If you have any feature requests or suggestions, feel free to create an issue on GitHub or contact me directly.